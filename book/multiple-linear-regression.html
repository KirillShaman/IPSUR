---
layout: chapter
title: Multiple Linear Regression
previous: simple-linear-regression.html
next: categorical-data-analysis.html
description: This chapter discusses regression of one response variable on multiple explanatory variables.
keywords: multiple linear regression R statistics
---

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Multiple Linear Regression</a>
<ul>
<li><a href="#sec-1-1">The Multiple Linear Regression Model</a>
<ul>
<li><a href="#sec-1-1-1">What does it mean?</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Estimation and Prediction</a>
<ul>
<li><a href="#sec-1-2-1">Parameter estimates</a></li>
<li><a href="#sec-1-2-2">Point Estimates of the Regression Surface</a></li>
<li><a href="#sec-1-2-3">Mean Square Error and Standard Error</a></li>
<li><a href="#sec-1-2-4">Interval Estimates of the Parameters</a></li>
<li><a href="#sec-1-2-5">Confidence and Prediction Intervals</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Model Utility and Inference</a>
<ul>
<li><a href="#sec-1-3-1">Multiple Coefficient of Determination</a></li>
<li><a href="#sec-1-3-2">Overall <i>F</i>-Test</a></li>
<li><a href="#sec-1-3-3">Student's <i>t</i> Tests</a></li>
</ul>
</li>
<li><a href="#sec-1-4">Polynomial Regression</a>
<ul>
<li><a href="#sec-1-4-1">Quadratic Regression Model</a></li>
</ul>
</li>
<li><a href="#sec-1-5">Interaction</a></li>
<li><a href="#sec-1-6">Qualitative Explanatory Variables</a>
<ul>
<li><a href="#sec-1-6-1">Graphing the Regression Lines</a></li>
</ul>
</li>
<li><a href="#sec-1-7">Partial <i>F</i> Statistic</a></li>
<li><a href="#sec-1-8">Residual Analysis and Diagnostic Tools</a></li>
<li><a href="#sec-1-9">Additional Topics</a>
<ul>
<li><a href="#sec-1-9-1">Nonlinear Regression</a></li>
<li><a href="#sec-1-9-2">Real Nonlinear Regression</a></li>
<li><a href="#sec-1-9-3">Multicollinearity</a></li>
<li><a href="#sec-1-9-4">Akaike's Information Criterion</a></li>
</ul>
</li>
<li><a href="#sec-1-10">Chapter Exercises</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Multiple Linear Regression</h2>
<div class="outline-text-2" id="text-1">


<p>
We know a lot about simple linear regression models, and a next step is to study multiple regression models that have more than one independent (explanatory) variable. In the discussion that follows we will assume that we have \(p\) explanatory variables, where \(p&gt;1\).
</p>
<p>
The language is phrased in matrix terms &ndash; for two reasons. First, it is quicker to write and (arguably) more pleasant to read. Second, the matrix approach will be required for later study of the subject; the reader might as well be introduced to it now.
</p>
<p>
Most of the results are stated without proof or with only a cursory justification. Those yearning for more should consult an advanced text in linear regression for details, such as <i>Applied Linear Regression Models</i> \cite{Neter1996} or <i>Linear Models: Least Squares and Alternatives</i> \cite{Rao1999}.
</p>


<ul>
<li>the basic MLR model, and how it relates to the SLR
</li>
<li>how to estimate the parameters and use those estimates to make predictions
</li>
<li>basic strategies to determine whether or not the model is doing a good job
</li>
<li>a few thoughts about selected applications of the MLR, such as polynomial, interaction, and dummy variable models
</li>
<li>some of the uses of residuals to diagnose problems
</li>
<li>hints about what will be coming later
</li>
</ul>



</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">The Multiple Linear Regression Model</h3>
<div class="outline-text-3" id="text-1-1">


<p>
The first thing to do is get some better notation. We will write 
\begin{equation}
\mathbf{Y}_{\mathrm{n}\times1}=
\begin{bmatrix}y_{1}\\
y_{2}\\
\vdots\\
y_{n}
\end{bmatrix},
\quad\mbox{and}\quad\mathbf{X}_{\mathrm{n}\times(\mathrm{p}+1)}=
\begin{bmatrix}1 & x_{11} & x_{21} & \cdots & x_{p1}\\
1 & x_{12} & x_{22} & \cdots & x_{p2}\\
\vdots & \vdots & \vdots & \ddots & \vdots\\
1 & x_{1n} & x_{2n} & \cdots & x_{pn}
\end{bmatrix}.
\end{equation}
The vector \(\mathbf{Y}\) is called the <i>response vector</i> \index{response vector} and the matrix \(\mathbf{X}\) is called the <i>model matrix</i> \index{model matrix}. As in Chapter <a href="#cha-simple-linear-regression">simple-linear-regression</a>, the most general assumption that relates \(\mathbf{Y}\) to \(\mathbf{X}\) is
\begin{equation}
\mathbf{Y}=\mu(\mathbf{X})+\upepsilon,
\end{equation}
where \(\mu\) is some function (the <i>signal</i>) and \(\upepsilon\) is the <i>noise</i> (everything else). We usually impose some structure on \(\mu\) and \(\upepsilon\). In particular, the standard multiple linear regression model\index{model!multiple linear regression} assumes
\begin{equation}
\mathbf{Y}=\mathbf{X}\upbeta+\upepsilon,
\end{equation}
where the parameter vector \(\upbeta\) looks like 
\begin{equation}
\upbeta_{(\mathrm{p}+1)\times1}=\begin{bmatrix}\beta_{0} & \beta_{1} & \cdots & \beta_{p}\end{bmatrix}^{\mathrm{T}},
\end{equation}
and the random vector \(\upepsilon_{\mathrm{n}\times1}=\begin{bmatrix}\epsilon_{1} &amp; \epsilon_{2} &amp; \cdots &amp; \epsilon_{n}\end{bmatrix}^{\mathrm{T}}\) is assumed to be distributed
\begin{equation}
\upepsilon\sim\mathsf{mvnorm}\left(\mathtt{mean}=\mathbf{0}_{\mathrm{n}\times1},\,\mathtt{sigma}=\sigma^{2}\mathbf{I}_{\mathrm{n}\times\mathrm{n}}\right).
\end{equation}

The assumption on \(\upepsilon\) is equivalent to the assumption that \(\epsilon_{1}\), \(\epsilon_{2}\), &hellip;, \(\epsilon_{n}\) are IID \(\mathsf{norm}(\mathtt{mean}=0,\,\mathtt{sd}=\sigma)\). It is a linear model because the quantity \(\mu(\mathbf{X})=\mathbf{X}\upbeta\) is linear in the parameters \(\beta_{0}\), \(\beta_{1}\), &hellip;, \(\beta_{p}\). It may be helpful to see the model in expanded form; the above matrix formulation is equivalent to the more lengthy
\begin{equation} 
Y_{i}=\beta_{0}+\beta_{1}x_{1i}+\beta_{2}x_{2i}+\cdots+\beta_{p}x_{pi}+\epsilon_{i},\quad i=1,2,\ldots,n.
\end{equation}

<b>Girth, Height, and Volume for Black Cherry trees.</b> \index{Data sets!trees@\texttt{trees}}
Measurements were made of the girth, height, and volume of timber in 31 felled black cherry trees. Note that girth is the diameter of the tree (in inches) measured at 4 ft 6 in above the ground. The variables are
</p>
<ol>
<li><code>Girth</code>: tree diameter in inches (denoted \(x_{1}\))
</li>
<li><code>Height</code>: tree height in feet (\(x_{2}\)).
</li>
<li><code>Volume</code>: volume of the tree in cubic feet. (\(y\))
</li>
</ol>


<p>
The data are in the <code>datasets</code> package and are already on the search path; they can be viewed with
</p>



<pre class="src src-R">head(trees)
</pre>


<pre class="example">
  Girth Height Volume
1   8.3     70   10.3
2   8.6     65   10.3
3   8.8     63   10.2
4  10.5     72   16.4
5  10.7     81   18.8
6  10.8     83   19.7
</pre>


<p>
Let us take a look at a visual display of the data. For multiple variables, instead of a simple scatterplot we use a scatterplot matrix which is made with the <code>splom</code> function in the <code>lattice</code> package \cite{Sarkarlattice} as shown below. The plot is shown in Figure <a href="#fig-splom-trees">splom-trees</a>.
</p>



<pre class="src src-R"><span style="color: #008b8b;">library</span>(lattice)
splom(trees)
</pre>







<div id="fig-splom-trees" class="figure">
  <p><img src="svg/splom-trees.svg" width=500 alt="svg/splom-trees.svg" /></p>
  <p>A scatterplot matrix of the <code>trees</code> data.</p>
</div>

<p>
The dependent (response) variable <code>Volume</code> is listed in the first row of the scatterplot matrix. Moving from left to right, we see an approximately linear relationship between <code>Volume</code> and the independent (explanatory) variables <code>Height</code> and <code>Girth</code>. A first guess at a model for these data might be
\begin{equation}
Y=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{2}+\epsilon,
\end{equation}
in which case the quantity \(\mu(x_{1},x_{2})=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{2}\) would represent the mean value of \(Y\) at the point \((x_{1},x_{2})\).
</p>

</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">What does it mean?</h4>
<div class="outline-text-4" id="text-1-1-1">


<p>
The interpretation is simple. The intercept \(\beta_{0}\) represents the mean <code>Volume</code> when all other independent variables are zero. The parameter \(\beta_{i}\) represents the change in mean <code>Volume</code> when there is a unit increase in \(x_{i}\), while the other independent variable is held constant. For the <code>trees</code> data, \(\beta_{1}\) represents the change in average <code>Volume</code> as <code>Girth</code> increases by one unit when the <code>Height</code> is held constant, and \(\beta_{2}\) represents the change in average <code>Volume</code> as <code>Height</code> increases by one unit when the <code>Girth</code> is held constant. 
</p>

<p>
In simple linear regression, we had one independent variable and our linear regression surface was 1D, simply a line. In multiple regression there are many independent variables and so our linear regression surface will be many-D&hellip; in general, a hyperplane. But when there are only two explanatory variables the hyperplane is just an ordinary plane and we can look at it with a 3D scatterplot. 
</p>
<p>
One way to do this is with the \(\mathsf{R}\) Commander in the <code>Rcmdr</code> package \cite{Foxrcmdr}. It has a 3D scatterplot option under the <code>Graphs</code> menu. It is especially great because the resulting graph is dynamic; it can be moved around with the mouse, zoomed, <i>etc</i>. But that particular display does not translate well to a printed book.
</p>
<p>
Another way to do it is with the <code>scatterplot3d</code> function in the <code>scatterplot3d</code> package. The code follows, and the result is shown in Figure <a href="#fig-3D-scatterplot-trees">3D-scatterplot-trees</a>.
</p>



<pre class="src src-R"><span style="color: #008b8b;">library</span>(scatterplot3d)
s3d <span style="color: #008b8b;">&lt;-</span> with(trees, scatterplot3d(Girth, Height, Volume, 
                                 pch = 16, highlight.3d = <span style="color: #228b22;">TRUE</span>, 
                                 angle = 60))
fit <span style="color: #008b8b;">&lt;-</span> lm(Volume ~ Girth + Height, data = trees)
</pre>







<div id="fig-3D-scatterplot-trees" class="figure">
  <p><img src="svg/3D-scatterplot-trees.svg" width=500 alt="svg/3D-scatterplot-trees.svg" /></p>
  <p> A 3D scatterplot with regression plane for the <code>trees</code> data.</p>
</div>

<p>
Looking at the graph we see that the data points fall close to a plane in three dimensional space. (The plot looks remarkably good. In the author's experience it is rare to see points fit so well to the plane without some additional work.)
</p>
</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Estimation and Prediction</h3>
<div class="outline-text-3" id="text-1-2">



</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Parameter estimates</h4>
<div class="outline-text-4" id="text-1-2-1">


<p>
We will proceed exactly like we did in Section <a href="#sec-SLR-Estimation">SLR-Estimation</a>. We know
\begin{equation}
\upepsilon\sim\mathsf{mvnorm}\left(\mathtt{mean}=\mathbf{0}_{\mathrm{n}\times1},\,\mathtt{sigma}=\sigma^{2}\mathbf{I}_{\mathrm{n}\times\mathrm{n}}\right),
\end{equation}
which means that \(\mathbf{Y}=\mathbf{X}\upbeta+\upepsilon\) has an \(\mathsf{mvnorm}\left(\mathtt{mean}=\mathbf{X}\upbeta,\,\mathtt{sigma}=\sigma^{2}\mathbf{I}_{\mathrm{n}\times\mathrm{n}}\right)\) distribution. Therefore, the likelihood function\index{likelihood function} is
\begin{equation}
L(\upbeta,\sigma)=\frac{1}{2\pi^{n/2}\sigma}\exp\left\{ -\frac{1}{2\sigma^{2}}\left(\mathbf{Y}-\mathbf{X}\upbeta\right)^{\mathrm{T}}\left(\mathbf{Y}-\mathbf{X}\upbeta\right)\right\}.
\end{equation}

To <i>maximize</i> the likelihood\index{maximum likelihood} in \(\upbeta\), we need to <i>minimize</i> the quantity \(g(\upbeta)=\left(\mathbf{Y}-\mathbf{X}\upbeta\right)^{\mathrm{T}}\left(\mathbf{Y}-\mathbf{X}\upbeta\right)\). We do this by differentiating \(g\) with respect to \(\upbeta\). (It may be a good idea to brush up on the material in Appendices <a href="#sec-Linear-Algebra">Linear-Algebra</a> and <a href="#sec-Multivariable-Calculus">Multivariable-Calculus</a>.) First we will rewrite \(g\):
\begin{equation}
g(\upbeta)=\mathbf{Y}^{\mathrm{T}}\mathbf{Y}-\mathbf{Y}^{\mathrm{T}}\mathbf{X}\upbeta-\upbeta^{\mathrm{T}}\mathbf{X}^{\mathrm{T}}\mathbf{Y}+\upbeta^{\mathrm{T}}\mathbf{X}^{\mathrm{T}}\mathbf{X}\upbeta,
\end{equation}
which can be further simplified to \(g(\upbeta)=\mathbf{Y}^{\mathrm{T}}\mathbf{Y}-2\upbeta^{\mathrm{T}}\mathbf{X}^{\mathrm{T}}\mathbf{Y}+\upbeta^{\mathrm{T}}\mathbf{X}^{\mathrm{T}}\mathbf{X}\upbeta\) since \(\upbeta^{\mathrm{T}}\mathbf{X}^{\mathrm{T}}\mathbf{Y}\) is \(1\times1\) and thus equal to its transpose. Now we differentiate to get
\begin{equation}
\frac{\partial g}{\partial\upbeta}=\mathbf{0}-2\mathbf{X}^{\mathrm{T}}\mathbf{Y}+2\mathbf{X}^{\mathrm{T}}\mathbf{X}\upbeta,
\end{equation}
since \(\mathbf{X}^{\mathrm{T}}\mathbf{X}\) is symmetric. Setting the derivative equal to the zero vector yields the so called ``normal equations''\index{normal equations}
\begin{equation}
\mathbf{X}^{\mathrm{T}}\mathbf{X}\upbeta=\mathbf{X}^{\mathrm{T}}\mathbf{Y}.
\end{equation}

In the case that \(\mathbf{X}^{\mathrm{T}}\mathbf{X}\) is invertible
we may solve the equation for \(\upbeta\) to get the maximum likelihood estimator of \(\upbeta\) which we denote by \(\mathbf{b}\):
\begin{equation}
\mathbf{b}=\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{X}^{\mathrm{T}}\mathbf{Y}.\label{eq:b-formula-matrix}
\end{equation}

<div class="rem">
The formula in Equation <a href="#eq-b-formula-matrix">b-formula-matrix</a> is convenient for mathematical study but is inconvenient for numerical computation. Researchers have devised much more efficient algorithms for the actual calculation of the parameter estimates, and we do not explore them here.
</div>
</p>
<p>
<div class="rem">
We have only found a critical value, and have not actually shown that the critical value is a minimum. We omit the details and refer the interested reader to \cite{Rao1999}.
</div>
</p>

<p>
We do all of the above just as we would in simple linear regression. The powerhouse is the <code>lm</code>\index{lm@\texttt{lm}} function. Everything else is based on it. We separate explanatory variables in the model formula by a plus sign.
</p>



<pre class="src src-R">trees.lm <span style="color: #008b8b;">&lt;-</span> lm(Volume ~ Girth + Height, data = trees)
trees.lm
</pre>


<pre class="example">
X11cairo 
       2
 
Call:
lm(formula = Volume ~ Girth + Height, data = trees)

Coefficients:
(Intercept)        Girth       Height  
   -57.9877       4.7082       0.3393
</pre>


<p>
We see from the output that for the <code>trees</code> data our parameter estimates are 
\[
\mathbf{b}=\begin{bmatrix}-58.0 & 4.7 & 0.3\end{bmatrix},
\] 
and consequently our estimate of the mean response is \(\hat{\mu}\) given by 
\begin{alignat}{1}
\hat{\mu}(x_{1},x_{2})= & \ b_{0}+b_{1}x_{1}+b_{2}x_{2},\\
\approx & -58.0+4.7x_{1}+0.3x_{2}.
\end{alignat}
We could see the entire model matrix \(\mathbf{X}\) with the <code>model.matrix</code>\index{model.matrix@\texttt{model.matrix}} function, but in the interest of brevity we only show the first few rows. 
</p>



<pre class="src src-R">head(model.matrix(trees.lm))
</pre>


<pre class="example">
  (Intercept) Girth Height
1           1   8.3     70
2           1   8.6     65
3           1   8.8     63
4           1  10.5     72
5           1  10.7     81
6           1  10.8     83
</pre>


</div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Point Estimates of the Regression Surface</h4>
<div class="outline-text-4" id="text-1-2-2">


<p>
The parameter estimates \(\mathbf{b}\) make it easy to find the fitted values\index{fitted values}, \(\hat{\mathbf{Y}}\). We write them individually as \(\hat{Y}_{i}\), \(i=1,2,\ldots,n\), and recall that they are defined by
\begin{eqnarray}
\hat{Y}_{i} & = & \hat{\mu}(x_{1i},x_{2i}),\\
 & = & b_{0}+b_{1}x_{1i}+b_{2}x_{2i},\quad i=1,2,\ldots,n.
\end{eqnarray}
They are expressed more compactly by the matrix equation
\begin{equation}
\hat{\mathbf{Y}}=\mathbf{X}\mathbf{b}.
\end{equation}
From Equation <a href="#eq-b-formula-matrix">b-formula-matrix</a> we know that \(\mathbf{b}=\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{X}^{\mathrm{T}}\mathbf{Y}\), so we can rewrite
\begin{eqnarray}
\hat{\mathbf{Y}} & = & \mathbf{X}\left[\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{X}^{\mathrm{T}}\mathbf{Y}\right],\\
 & = & \mathbf{H}\mathbf{Y},
\end{eqnarray}
where \(\mathbf{H}=\mathbf{X}\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{X}^{\mathrm{T}}\) is appropriately named <i>the hat matrix</i>\index{hat matrix} because it ``puts the hat on \(\mathbf{Y}\)''. The hat matrix is very important in later courses. Some facts about \(\mathbf{H}\) are
</p><ul>
<li>\(\mathbf{H}\) is a symmetric square matrix, of dimension \(\mathrm{n}\times\mathrm{n}\).
</li>
<li>The diagonal entries \(h_{ii}\) satisfy \(0\leq h_{ii}\leq1\) (compare to Equation <a href="#eq-slr-leverage-between">slr-leverage-between</a>).
</li>
<li>The trace is \(\mathrm{tr}(\mathbf{H})=p\).
</li>
<li>\(\mathbf{H}\) is <i>idempotent</i> (also known as a <i>projection matrix</i>) which means that \(\mathbf{H}^{2}=\mathbf{H}\). The same is true of \(\mathbf{I}-\mathbf{H}\).
</li>
</ul>


<p>
Now let us write a column vector \(\mathbf{x}_{0}=(x_{10},x_{20})^{\mathrm{T}}\) to denote given values of the explanatory variables <code>Girth =</code> \(x_{10}\) and <code>Height =</code> \(x_{20}\). These values may match those of the collected data, or they may be completely new values not observed in the original data set. We may use the parameter estimates to find \(\hat{Y}(\mathbf{x}_{0})\), which will give us
</p>
<ol>
<li>an estimate of \(\mu(\mathbf{x}_{0})\), the mean value of a future observation at \(\mathbf{x}_{0}\), and

</li>
<li>a prediction for \(Y(\mathbf{x}_{0})\), the actual value of a future observation at \(\mathbf{x}_{0}\).
</li>
</ol>


<p>
We can represent \(\hat{Y}(\mathbf{x}_{0})\) by the matrix equation
\begin{equation}
\hat{Y}(\mathbf{x}_{0})=\mathbf{x}_{0}^{\mathrm{T}}\mathbf{b},\label{eq:mlr-single-yhat-matrix}
\end{equation}
which is just a fancy way to write
\begin{equation}
\hat{Y}(x_{10},x_{20})=b_{0}+b_{1}x_{10}+b_{2}x_{20}.
\end{equation}
</p>
<p> 
If we wanted to predict the average volume of black cherry trees that have <code>Girth = 15</code> in and are <code>Height = 77</code> ft tall then we would use the estimate 
\begin{alignat*}{1}
\hat{\mu}(15,\,77)= & -58+4.7(15)+0.3(77),\\
\approx & 35.6\mbox{\,\ ft}^{3}.
\end{alignat*}

We would use the same estimate \(\hat{Y}=35.6\) to predict the measured <code>Volume</code> of another black cherry tree &ndash; yet to be observed &ndash; that has <code>Girth = 15</code> in and is <code>Height = 77</code> ft tall.
</p>

<p>
The fitted values are stored inside <code>trees.lm</code> and may be accessed with the <code>fitted</code> function. We only show the first five fitted values.
</p>



<pre class="src src-R">fitted(trees.lm)[1:5]
</pre>


<pre class="example">
        1         2         3         4         5 
 4.837660  4.553852  4.816981 15.874115 19.869008
</pre>


<p>
The syntax for general prediction does not change much from simple linear regression. The computations are done with the <code>predict</code> function as described below. 
</p>
<p>
The only difference from SLR is in the way we tell \(\mathsf{R}\) the values of the explanatory variables for which we want predictions. In SLR we had only one independent variable but in MLR we have many (for the <code>trees</code> data we have two). We will store values for the independent variables in the data frame <code>new</code>, which has two columns (one for each independent variable) and three rows (we shall make predictions at three different locations).
</p>



<pre class="src src-R">new <span style="color: #008b8b;">&lt;-</span> data.frame(Girth = c(9.1, 11.6, 12.5), Height = c(69, 74, 87))
</pre>


<p>
We can view the locations at which we will predict:
</p>



<pre class="src src-R">new
</pre>


<pre class="example">
  Girth Height
1   9.1     69
2  11.6     74
3  12.5     87
</pre>


<p>
We continue just like we would have done in SLR.
</p>



<pre class="src src-R">predict(trees.lm, newdata = new)
</pre>


<pre class="example">
        1         2         3 
 8.264937 21.731594 30.379205
</pre>




<p>
Using the <code>trees</code> data,
</p><ol>
<li>Report a point estimate of the mean <code>Volume</code> of a tree of <code>Girth</code> 9.1 in and <code>Height</code> 69 ft.

<p>
   The fitted value for \(x_{1}=9.1\) and \(x_{2}=69\) is \(  8.3 \), so a point estimate would be \(  8.3 \) cubic feet. 
</p>
</li>
<li>Report a point prediction for and a 95% prediction interval for the <code>Volume</code> of a hypothetical tree of <code>Girth</code> 12.5 in and <code>Height</code> 87 ft.

<p>
   The fitted value for \(x_{1} = 12.5\) and \(x_{2} = 87\) is \(  30.4 \), so a point prediction for the <code>Volume</code> is \(  30.4 \) cubic feet. 
</p></li>
</ol>


</div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Mean Square Error and Standard Error</h4>
<div class="outline-text-4" id="text-1-2-3">


<p>
The residuals are given by
\begin{equation}
\mathbf{E}=\mathbf{Y}-\hat{\mathbf{Y}}=\mathbf{Y}-\mathbf{H}\mathbf{Y}=(\mathbf{I}-\mathbf{H})\mathbf{Y}.
\end{equation}
Now we can use Theorem <a href="#thm-mvnorm-dist-matrix-prod">mvnorm-dist-matrix-prod</a> to see that the residuals are distributed
\begin{equation}
\mathbf{E}\sim\mathsf{mvnorm}(\mathtt{mean}=\mathbf{0},\,\mathtt{sigma}=\sigma^{2}(\mathbf{I}-\mathbf{H})),
\end{equation}
since \((\mathbf{I}-\mathbf{H})\mathbf{X}\upbeta=\mathbf{X}\upbeta-\mathbf{X}\upbeta=\mathbf{0}\) and \((\mathbf{I}-\mathbf{H})\,(\sigma^{2}\mathbf{I})\,(\mathbf{I}-\mathbf{H})^{\mathrm{T}}=\sigma^{2}(\mathbf{I}-\mathbf{H})^{2}=\sigma^{2}(\mathbf{I}-\mathbf{H})\). The sum of squared errors \(SSE\) is just
\begin{equation}
SSE=\mathbf{E}^{\mathrm{T}}\mathbf{E}=\mathbf{Y}^{\mathrm{T}}(\mathbf{I}-\mathbf{H})(\mathbf{I}-\mathbf{H})\mathbf{Y}=\mathbf{Y}^{\mathrm{T}}(\mathbf{I}-\mathbf{H})\mathbf{Y}.
\end{equation}
Recall that in SLR we had two parameters (\(\beta_{0}\) and \(\beta_{1}\)) in our regression model and we estimated \(\sigma^{2}\) with \(s^{2}=SSE/(n-2)\). In MLR, we have \(p+1\) parameters in our regression model and we might guess that to estimate \(\sigma^{2}\) we would use the <i>mean square error</i> \(S^{2}\) defined by 
\begin{equation}
S^{2}=\frac{SSE}{n-(p+1)}.
\end{equation}
That would be a good guess. The <i>residual standard error</i> is \(S=\sqrt{S^{2}}\).
</p>

<p>
The residuals are also stored with <code>trees.lm</code> and may be accessed with the <code>residuals</code> function. We only show the first five residuals.
</p>



<pre class="src src-R">residuals(trees.lm)[1:5]
</pre>



<pre class="example">  1 
8.3
  1 
8.3
   3 
30.4
   3 
30.4
         1          2          3          4          5 
 5.4623403  5.7461484  5.3830187  0.5258848 -1.0690084
</pre>


<p>
The <code>summary</code> function output (shown later) lists the <code>Residual Standard Error</code> which is just \(S=\sqrt{S^{2}}\). It is stored in the <code>sigma</code> component of the <code>summary</code> object.
</p>



<pre class="src src-R">treesumry <span style="color: #008b8b;">&lt;-</span> summary(trees.lm)
treesumry$sigma
</pre>


<pre class="example">
[1] 3.881832
</pre>


<p>
For the <code>trees</code> data we find \(s\approx  3.882 \).
</p>
</div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">Interval Estimates of the Parameters</h4>
<div class="outline-text-4" id="text-1-2-4">


<p>
We showed in Section <a href="#sub-mlr-parameter-estimates">mlr-parameter-estimates</a> that \(\mathbf{b}=\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{X}^{\mathrm{T}}\mathbf{Y}\), which is really just a big matrix &ndash; namely \(\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{X}^{\mathrm{T}}\) &ndash; multiplied by \(\mathbf{Y}\). It stands to reason that the sampling distribution of \(\mathbf{b}\) would be intimately related to the distribution of \(\mathbf{Y}\), which we assumed to be
\begin{equation}
\mathbf{Y}\sim\mathsf{mvnorm}\left(\mathtt{mean}=\mathbf{X}\upbeta,\,\mathtt{sigma}=\sigma^{2}\mathbf{I}\right).
\end{equation}
Now recall Theorem <a href="#thm-mvnorm-dist-matrix-prod">mvnorm-dist-matrix-prod</a> that we said we were going to need eventually (the time is now). That proposition guarantees that
\begin{equation}
\mathbf{b}\sim\mathsf{mvnorm}\left(\mathtt{mean}=\upbeta,\,\mathtt{sigma}=\sigma^{2}\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\right),\label{eq:distn-b-mlr}
\end{equation}
since
\begin{equation}
\mathbb{E}\mathbf{b}=\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{X}^{\mathrm{T}}(\mathbf{X}\upbeta)=\upbeta,
\end{equation}
and
\begin{equation}
\mbox{Var}(\mathbf{b})=\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{X}^{\mathrm{T}}(\sigma^{2}\mathbf{I})\mathbf{X}\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}=\sigma^{2}\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1},
\end{equation}
the first equality following because the matrix \(\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\) is symmetric.
</p>
<p>
There is a lot that we can glean from Equation <a href="#eq-distn-b-mlr">distn-b-mlr</a>. First, it follows that the estimator \(\mathbf{b}\) is unbiased (see Section <a href="#sec-Point-Estimation-1">Point-Estimation-1</a>). Second, the variances of \(b_{0}\), \(b_{1}\), &hellip;, \(b_{n}\) are exactly the diagonal elements of \(\sigma^{2}\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\), which is completely known except for that pesky parameter \(\sigma^{2}\). Third, we can estimate the standard error of \(b_{i}\) (denoted \(S_{b_{i}}\)) with the mean square error \(S\) (defined in the previous section) multiplied by the corresponding diagonal element of \(\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\). Finally, given estimates of the standard errors we may construct confidence intervals for \(\beta_{i}\) with an interval that looks like
\begin{equation}
b_{i}\pm\mathsf{t}_{\alpha/2}(\mathtt{df}=n-p-1)S_{b_{i}}.
\end{equation}
The degrees of freedom for the Student's \(t\) distribution
are the same as the denominator of \(S^{2}\). 
</p>

<p>
To get confidence intervals for the parameters we need only use <code>confint</code>\index{confint@\texttt{confint}}:
</p>



<pre class="src src-R">confint(trees.lm)
</pre>


<pre class="example">
[1] 3.882
                   2.5 %      97.5 %
(Intercept) -75.68226247 -40.2930554
Girth         4.16683899   5.2494820
Height        0.07264863   0.6058538
</pre>




<p>
For example, using the calculations above we say that for the regression model <code>Volume ~ Girth + Height</code> we are 95% confident that the parameter \(\beta_{1}\) lies somewhere in the interval \( [  4.2,  5.2 ] \).
</p>
</div>

</div>

<div id="outline-container-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">Confidence and Prediction Intervals</h4>
<div class="outline-text-4" id="text-1-2-5">


<p>
We saw in Section <a href="#sub-mlr-point-est-regsurface">mlr-point-est-regsurface</a> how to make point estimates of the mean value of additional observations and predict values of future observations, but how good are our estimates? We need confidence and prediction intervals to gauge their accuracy, and lucky for us the formulas look similar to the ones we saw in SLR.
</p>
<p>
In Equation <a href="#eq-mlr-single-yhat-matrix">mlr-single-yhat-matrix</a> we wrote \( \hat{Y}(\mathbf{x}_{0})=\mathbf{x}_{0}^{\mathrm{T}}\mathbf{b} \), and in Equation <a href="#eq-distn-b-mlr">distn-b-mlr</a> we saw that
\begin{equation}
\mathbf{b}\sim\mathsf{mvnorm}\left(\mathtt{mean}=\upbeta,\,\mathtt{sigma}=\sigma^{2}\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\right).
\end{equation}
The following is therefore immediate from Theorem <a href="#thm-mvnorm-dist-matrix-prod">mvnorm-dist-matrix-prod</a>:
\begin{equation}
\hat{Y}(\mathbf{x}_{0})\sim\mathsf{mvnorm}\left(\mathtt{mean}=\mathbf{x}_{0}^{\mathrm{T}}\upbeta,\,\mathtt{sigma}=\sigma^{2}\mathbf{x}_{0}^{\mathrm{T}}\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{x}_{0}\right).
\end{equation}
It should be no surprise that confidence intervals for the mean value of a future observation at the location \(\mathbf{x}_{0}=\begin{bmatrix}x_{10} &amp; x_{20} &amp; \ldots &amp; x_{p0}\end{bmatrix}^{\mathrm{T}}\) are given by
\begin{equation}
\hat{Y}(\mathbf{x}_{0})\pm\mathsf{t}_{\alpha/2}(\mathtt{df}=n-p-1)\, S\sqrt{\mathbf{x}_{0}^{\mathrm{T}}\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{x}_{0}}.
\end{equation}
Intuitively, \(\mathbf{x}_{0}^{\mathrm{T}}\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{x}_{0}\) measures the distance of \(\mathbf{x}_{0}\) from the center of the data. The degrees of freedom in the Student's \(t\) critical value are \(n-(p+1)\) because we need to estimate \(p+1\) parameters.
</p>
<p>
Prediction intervals for a new observation at \(\mathbf{x}_{0}\) are given by
\begin{equation}
\hat{Y}(\mathbf{x}_{0})\pm\mathsf{t}_{\alpha/2}(\mathtt{df}=n-p-1)\, S\sqrt{1+\mathbf{x}_{0}^{\mathrm{T}}\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\mathbf{x}_{0}}.
\end{equation}
The prediction intervals are wider than the confidence intervals, just as in Section <a href="#sub-slr-interval-est-regline">slr-interval-est-regline</a>.
</p>


<p>
The syntax is identical to that used in SLR, with the proviso that we need to specify values of the independent variables in the data frame <code>new</code> as we did in Section <a href="#sub-slr-interval-est-regline">slr-interval-est-regline</a> (which we repeat here for illustration).
</p>



<pre class="src src-R">new <span style="color: #008b8b;">&lt;-</span> data.frame(Girth = c(9.1, 11.6, 12.5), Height = c(69, 74, 87))
</pre>


<p>
Confidence intervals are given by
</p>



<pre class="src src-R">predict(trees.lm, newdata = new, interval = <span style="color: #8b2252;">"confidence"</span>)
</pre>


<pre class="example">
[1] 4.2
[1] 5.2
        fit      lwr      upr
1  8.264937  5.77240 10.75747
2 21.731594 20.11110 23.35208
3 30.379205 26.90964 33.84877
</pre>




<p>
Prediction intervals are given by
</p>



<pre class="src src-R">predict(trees.lm, newdata = new, interval = <span style="color: #8b2252;">"prediction"</span>)
</pre>


<pre class="example">
        fit         lwr      upr
1  8.264937 -0.06814444 16.59802
2 21.731594 13.61657775 29.84661
3 30.379205 21.70364103 39.05477
</pre>




<p>
As before, the interval type is decided by the <code>interval</code> argument and the default confidence level is 95% (which can be changed with the <code>level</code> argument).
</p>
<p>
Using the <code>trees</code> data, 
</p>
<ol>
<li>Report a 95% confidence interval for the mean <code>Volume</code> of a tree of <code>Girth</code> 9.1 in and <code>Height</code> 69 ft.

<p>
   The 95% CI is given by \( [  5.8,  10.8 ] \), so with 95% confidence the mean <code>Volume</code> lies somewhere between \(  5.8 \) cubic feet and \(  10.8 \) cubic feet.
</p>
</li>
<li>Report a 95% prediction interval for the <code>Volume</code> of a hypothetical tree of <code>Girth</code> 12.5 in and <code>Height</code> 87 ft.

<p>
   The 95% prediction interval is given by \( [  26.9,  33.8 ] \), so with 95% confidence we may assert that the hypothetical <code>Volume</code> of a tree of <code>Girth</code> 12.5 in and <code>Height</code> 87 ft would lie somewhere between \(  26.9 \) cubic feet and \(  33.8 \) feet.
</p></li>
</ol>



</div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">Model Utility and Inference</h3>
<div class="outline-text-3" id="text-1-3">



</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Multiple Coefficient of Determination</h4>
<div class="outline-text-4" id="text-1-3-1">


<p>
We saw in Section <a href="#sub-mlr-mse-se">mlr-mse-se</a> that the error sum of squares \(SSE\) can be conveniently written in MLR as 
\begin{equation}
SSE=\mathbf{Y}^{\mathrm{T}}(\mathbf{I}-\mathbf{H})\mathbf{Y}.\label{eq:mlr-sse-matrix}
\end{equation}
It turns out that there are equally convenient formulas for the total sum of squares \(SSTO\) and the regression sum of squares \(SSR\). They are:
\begin{alignat}{1}
SSTO= & \mathbf{Y}^{\mathrm{T}}\left(\mathbf{I}-\frac{1}{n}\mathbf{J}\right)\mathbf{Y}\label{eq:mlr-ssto-matrix}
\end{alignat}
and
\begin{alignat}{1}
SSR= & \mathbf{Y}^{\mathrm{T}}\left(\mathbf{H}-\frac{1}{n}\mathbf{J}\right)\mathbf{Y}.\label{eq:mlr-ssr-matrix}
\end{alignat}
(The matrix \(\mathbf{J}\) is defined in Appendix <a href="#sec-Linear-Algebra">Linear-Algebra</a>.) Immediately from Equations <a href="#eq-mlr-sse-matrix">mlr-sse-matrix</a>, <a href="#eq-mlr-ssto-matrix">mlr-ssto-matrix</a>, and <a href="#eq-mlr-ssr-matrix">mlr-ssr-matrix</a> we get the <i>Anova Equality</i>
\begin{equation} 
SSTO=SSE+SSR.
\end{equation}
(See Exercise <a href="#xca-anova-equality">anova-equality</a>.) We define the <i>multiple coefficient of determination</i> by the formula
\begin{equation} 
R^{2}=1-\frac{SSE}{SSTO}.
\end{equation}

We interpret \(R^{2}\) as the proportion of total variation that is explained by the multiple regression model. In MLR we must be careful, however, because the value of \(R^{2}\) can be artificially inflated by the addition of explanatory variables to the model, regardless of whether or not the added variables are useful with respect to prediction of the response variable. In fact, it can be proved that the addition of a single explanatory variable to a regression model will increase the value of \(R^{2}\), <i>no matter how worthless</i> the explanatory variable is. We could model the height of the ocean tides, then add a variable for the length of cheetah tongues on the Serengeti plain, and our \(R^{2}\) would inevitably increase. 
</p>
<p>
This is a problem, because as the philosopher, Occam, once said: ``causes should not be multiplied beyond necessity''. We address the problem by penalizing \(R^{2}\) when parameters are added to the model. The result is an <i>adjusted</i> \(R^{2}\) which we denote by \(\overline{R}^{2}\).
\begin{equation}
\overline{R}^{2}=\left(R^{2}-\frac{p}{n-1}\right)\left(\frac{n-1}{n-p-1}\right).
\end{equation}
It is good practice for the statistician to weigh both \(R^{2}\) and \(\overline{R}^{2}\) during assessment of model utility. In many cases their values will be very close to each other. If their values differ substantially, or if one changes dramatically when an explanatory variable is added, then (s)he should take a closer look at the explanatory variables in the model.
</p>
<p>
For the <code>trees</code> data, we can get \(R^{2}\) and \(\overline{R}^{2}\) from the <code>summary</code> output or access the values directly by name as shown (recall that we stored the <code>summary</code> object in <code>treesumry</code>).
</p>



<pre class="src src-R">treesumry$r.squared
</pre>


<pre class="example">
[1] 5.8
[1] 10.8
[1] 5.8
[1] 10.8
[1] 26.9
[1] 33.8
[1] 26.9
[1] 33.8
[1] 0.94795
</pre>





<pre class="src src-R">treesumry$adj.r.squared
</pre>


<pre class="example">
[1] 0.9442322
</pre>


<p>
High values of \(R^{2}\) and \( \overline{R}^2 \) such as these indicate that the model fits very well, which agrees with what we saw in Figure <a href="#fig-3D-scatterplot-trees">3D-scatterplot-trees</a>.
</p>
</div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Overall <i>F</i>-Test</h4>
<div class="outline-text-4" id="text-1-3-2">


<p>
Another way to assess the model's utility is to to test the hypothesis
\[
H_{0}:\beta_{1}=\beta_{2}=\cdots=\beta_{p}=0\mbox{ versus }H_{1}:\mbox{ at least one $\beta_{i}\neq0$}.
\]
The idea is that if all \(\beta_{i}\)'s were zero, then the explanatory variables \(X_{1},\ldots,X_{p}\) would be worthless predictors for the response variable \(Y\). We can test the above hypothesis with the overall \(F\) statistic, which in MLR is defined by
\begin{equation}
F=\frac{SSR/p}{SSE/(n-p-1)}.
\end{equation}
When the regression assumptions hold and under \(H_{0}\), it can be shown that \(F\sim\mathsf{f}(\mathtt{df1}=p,\,\mathtt{df2}=n-p-1)\). We reject \(H_{0}\) when \(F\) is large, that is, when the explained variation is large relative to the unexplained variation.
</p>

<p>
The overall \(F\) statistic and its associated <i>p</i>-value is listed at the bottom of the <code>summary</code> output, or we can access it directly by name; it is stored in the <code>fstatistic</code> component of the <code>summary</code> object. 
</p>



<pre class="src src-R">treesumry$fstatistic
</pre>


<pre class="example">
   value    numdf    dendf 
254.9723   2.0000  28.0000
</pre>


<p>
For the <code>trees</code> data, we see that \( F =  254.972337410669 \) with a <i>p</i>-value <code>&lt; 2.2e-16</code>. Consequently we reject \(H_{0}\), that is, the data provide strong evidence that not all \(\beta_{i}\)'s are zero.
</p>
</div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">Student's <i>t</i> Tests</h4>
<div class="outline-text-4" id="text-1-3-3">


<p>
We know that
\begin{equation}
\mathbf{b}\sim\mathsf{mvnorm}\left(\mathtt{mean}=\upbeta,\,\mathtt{sigma}=\sigma^{2}\left(\mathbf{X}^{\mathrm{T}}\mathbf{X}\right)^{-1}\right)
\end{equation}
and we have seen how to test the hypothesis \(H_{0}:\beta_{1}=\beta_{2}=\cdots=\beta_{p}=0\), but let us now consider the test
\begin{equation}
H_{0}:\beta_{i}=0\mbox{ versus }H_{1}:\beta_{i}\neq0,
\end{equation}
where \(\beta_{i}\) is the coefficient for the \(i^{\textrm{th}}\) independent variable. We test the hypothesis by calculating a statistic, examining it's null distribution, and rejecting \(H_{0}\) if the <i>p-value</i> is small. If \(H_{0}\) is rejected, then we conclude that there is a significant relationship between \(Y\) and \(x_{i}\) <i>in the regression model</i> \(Y\sim(x_{1},\ldots,x_{p})\). This last part of the sentence is very important because the significance of the variable \(x_{i}\) sometimes depends on the presence of other independent variables in the model
</p>
<p>
To test the hypothesis we go to find the sampling distribution of \( b_{i} \), the estimator of the corresponding parameter \( \beta_{i} \), when the null hypothesis is true. We saw in Section <a href="#sub-mlr-interval-est-params">mlr-interval-est-params</a> that 
\begin{equation}
T_{i}=\frac{b_{i}-\beta_{i}}{S_{b_{i}}}
\end{equation}
has a Student's \(t\) distribution with \(n-(p+1)\) degrees of freedom. (Remember, we are estimating \(p+1\) parameters.) Consequently, under the null hypothesis \(H_{0}:\beta_{i}=0\) the statistic \(t_{i}=b_{i}/S_{b_{i}}\) has a \(\mathsf{t}(\mathtt{df}=n-p-1)\) distribution.
</p>


<p>
The Student's \(t\) tests for significance of the individual explanatory variables are shown in the <code>summary</code> output.
</p>



<pre class="src src-R">treesumry
</pre>



<pre class="example">   value 
254.9723
 
Call:
lm(formula = Volume ~ Girth + Height, data = trees)

Residuals:
    Min      1Q  Median      3Q     Max 
-6.4065 -2.6493 -0.2876  2.2003  8.4847 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) -57.9877     8.6382  -6.713 2.75e-07 ***
Girth         4.7082     0.2643  17.816  &lt; 2e-16 ***
Height        0.3393     0.1302   2.607   0.0145 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 

Residual standard error: 3.882 on 28 degrees of freedom
Multiple R-squared: 0.948,	Adjusted R-squared: 0.9442 
F-statistic:   255 on 2 and 28 DF,  p-value: &lt; 2.2e-16
</pre>


<p>
We see from the <i>p-values</i> that there is a significant linear relationship between <code>Volume</code> and <code>Girth</code> and between <code>Volume</code> and <code>Height</code> in the regression model <code>Volume ~ Girth + Height</code>. Further, it appears that the <code>Intercept</code> is significant in the aforementioned model.
</p>
</div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">Polynomial Regression</h3>
<div class="outline-text-3" id="text-1-4">



</div>

<div id="outline-container-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">Quadratic Regression Model</h4>
<div class="outline-text-4" id="text-1-4-1">


<p>
In each of the previous sections we assumed that \(\mu\) was a linear function of the explanatory variables. For example, in SLR we assumed that \(\mu(x)=\beta_{0}+\beta_{1}x\), and in our previous MLR examples we assumed \(\mu(x_{1},x_{2})=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{2}\). In every case the scatterplots indicated that our assumption was reasonable. Sometimes, however, plots of the data suggest that the linear model is incomplete and should be modified.
</p>



<pre class="src src-R">qplot(Girth, Volume, data = trees)
</pre>







<div id="fig-Scatterplot-Volume-Girth-trees" class="figure">
  <p><img src="svg/Scatterplot-Volume-Girth-trees.svg" width=500 alt="svg/Scatterplot-Volume-Girth-trees.svg" /></p>
  <p>A scatterplot of <code>Volume</code> versus <code>Girth</code> for the <code>trees</code> data.</p>
</div>

<p>
For example, let us examine a scatterplot of <code>Volume</code> versus <code>Girth</code> a little more closely. See Figure <a href="#fig-Scatterplot-Volume-Girth-trees">Scatterplot-Volume-Girth-trees</a>. There might be a slight curvature to the data; the volume curves ever so slightly upward as the girth increases. After looking at the plot we might try to capture the curvature with a mean response such as 
\begin{equation}
\mu(x_{1})=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{1}^{2}.
\end{equation}
The model associated with this choice of \(\mu\) is
\begin{equation}
Y=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{1}^{2}+\epsilon.
\end{equation}
The regression assumptions are the same. Almost everything indeed is the same. In fact, it is still called a ``linear regression model'', since the mean response \(\mu\) is linear <i>in the parameters</i> \(\beta_{0}\), \(\beta_{1}\), and \(\beta_{2}\). 
</p>
<p>
<b>However, there is one important difference.</b> When we introduce the squared variable in the model we inadvertently also introduce strong dependence between the terms which can cause significant numerical problems when it comes time to calculate the parameter estimates. Therefore, we should usually rescale the independent variable to have mean zero (and even variance one if we wish) <b>before</b> fitting the model. That is, we replace the \(x_{i}\)'s with \(x_{i}-\overline{x}\) (or \((x_{i}-\overline{x})/s\)) before fitting the model
</p>

<p>
There are multiple ways to fit a quadratic model to the variables <code>Volume</code> and <code>Girth</code> using \(\mathsf{R}\).
</p><ol>
<li>One way would be to square the values for <code>Girth</code> and save them in a vector <code>Girthsq</code>. Next, fit the linear model <code>Volume ~ Girth + Girthsq</code>. 
</li>
<li>A second way would be to use the <i>insulate</i> function in \(\mathsf{R}\), denoted by <code>I</code>:
<pre class="example">
Volume ~ Girth + I(Girth^2)
</pre>

</li>
</ol>

<p>The second method is shorter than the first but the end result is the same. And once we calculate and store the fitted model (in, say, <code>treesquad.lm</code>) all of the previous comments regarding \(\mathsf{R}\) apply.  
</p><ol>
<li>A third and ``right'' way to do it is with orthogonal polynomials:
<pre class="example">
 Volume ~ poly(Girth, degree = 2)
</pre>

<p>   See <code>?poly</code> and <code>?cars</code> for more information. Note that we can recover the approach in 2 with <code>poly(Girth, degree = 2, raw = TRUE)</code>.
</p></li>
</ol>


<p>
We will fit the quadratic model to the <code>trees</code> data and display the results with <code>summary</code>, being careful to rescale the data before fitting the model. We may rescale the <code>Girth</code> variable to have zero mean and unit variance on-the-fly with the <code>scale</code> function.
</p>



<pre class="src src-R">treesquad.lm <span style="color: #008b8b;">&lt;-</span> lm(Volume ~ scale(Girth) + I(scale(Girth)^2),                    data = trees)
summary(treesquad.lm)
</pre>



<pre class="example">X11cairo 
       2
 
Call:
lm(formula = Volume ~ scale(Girth) + I(scale(Girth)^2), data = trees)

Residuals:
    Min      1Q  Median      3Q     Max 
-5.4889 -2.4293 -0.3718  2.0764  7.6447 

Coefficients:
                  Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)        27.7452     0.8161  33.996  &lt; 2e-16 ***
scale(Girth)       14.5995     0.6773  21.557  &lt; 2e-16 ***
I(scale(Girth)^2)   2.5067     0.5729   4.376 0.000152 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 

Residual standard error: 3.335 on 28 degrees of freedom
Multiple R-squared: 0.9616,	Adjusted R-squared: 0.9588 
F-statistic: 350.5 on 2 and 28 DF,  p-value: &lt; 2.2e-16
</pre>


<p>
We see that the \(F\) statistic indicates the overall model including <code>Girth</code> and <code>Girth^2</code> is significant. Further, there is strong evidence that both <code>Girth</code> and <code>Girth^2</code> are significantly related to <code>Volume</code>. We may examine a scatterplot together with the fitted quadratic function using the <code>lines</code> function, which adds a line to the plot tracing the estimated mean response.
</p>



<pre class="src src-R">a <span style="color: #008b8b;">&lt;-</span> ggplot(trees, aes(scale(Girth), Volume))
a + stat_smooth(method = lm, formula = y ~ poly(x, 2)) + geom_point()
</pre>







<div id="fig-Fitting-the-Quadratic" class="figure">
  <p><img src="svg/Fitting-the-Quadratic.svg" width=500 alt="svg/Fitting-the-Quadratic.svg" /></p>
  <p>A quadratic model for the <code>trees</code> data.</p>
</div>

<p>
The plot is shown in Figure <a href="#fig-Fitting-the-Quadratic">Fitting-the-Quadratic</a>. Pay attention to the scale on the \(x\)-axis: it is on the scale of the transformed <code>Girth</code> data and not on the original scale.
</p>


<p>
<div class="rem">
When a model includes a quadratic term for an independent variable, it is customary to also include the linear term in the model. The principle is called <i>parsimony</i>. More generally, if the researcher decides to include \(x^{m}\) as a term in the model, then (s)he should also include all lower order terms \(x\), \(x^{2}\), &hellip;,\(x^{m-1}\) in the model.
</div>
</p>
<p>
We do estimation/prediction the same way that we did in Section <a href="#sub-mlr-point-est-regsurface">mlr-point-est-regsurface</a>, except we do not need a <code>Height</code> column in the dataframe <code>new</code> since the variable is not included in the quadratic model.
</p>



<pre class="src src-R">new <span style="color: #008b8b;">&lt;-</span> data.frame(Girth = c(9.1, 11.6, 12.5))
predict(treesquad.lm, newdata = new, interval = <span style="color: #8b2252;">"prediction"</span>)
</pre>


<pre class="example">
X11cairo 
       2
       fit       lwr      upr
1 11.56982  4.347426 18.79221
2 20.30615 13.299050 27.31325
3 25.92290 18.972934 32.87286
</pre>


<p>
The predictions and intervals are slightly different from what they were previously. Notice that it was not necessary to rescale the <code>Girth</code> prediction data before input to the <code>predict</code> function; the model did the rescaling for us automatically.
</p>
<p>
<div class="rem">
We have mentioned on several occasions that it is important to rescale the explanatory variables for polynomial regression. Watch what happens if we ignore this advice:
</p>



<pre class="src src-R">summary(lm(Volume ~ Girth + I(Girth^2), data = trees))
</pre>


<p>
Now nothing is significant in the model except <code>Girth^2</code>. We could delete the <code>Intercept</code> and <code>Girth</code> from the model, but the model would no longer be <i>parsimonious</i>. A novice may see the output and be confused about how to proceed, while the seasoned statistician recognizes immediately that <code>Girth</code> and <code>Girth^2</code> are highly correlated (see Section <a href="#sub-Multicollinearity">Multicollinearity</a>). The only remedy to this ailment is to rescale <code>Girth</code>, which we should have done in the first place.
</p>
<p>
In Example <a href="#exa-mlr-trees-poly-no-rescale">mlr-trees-poly-no-rescale</a> of Section <a href="#sec-Partial-F-Statistic">Partial-F-Statistic</a> we investigate this issue further.
</p>
<p>
</div>
</p>
</div>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">Interaction</h3>
<div class="outline-text-3" id="text-1-5">


<p>
In our model for tree volume there have been two independent variables: <code>Girth</code> and <code>Height</code>. We may suspect that the independent variables are related, that is, values of one variable may tend to influence values of the other. It may be desirable to include an additional term in our model to try and capture the dependence between the variables. Interaction terms are formed by multiplying one (or more) explanatory variable(s) by another. 
</p>

<p>
Perhaps the <code>Girth</code> and <code>Height</code> of the tree interact to influence the its <code>Volume</code>; we would like to investigate whether the model (<code>Girth</code> = \(x_{1}\) and <code>Height</code> = \(x_{2}\)) 
\begin{equation}
Y=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{2}+\epsilon
\end{equation}
would be significantly improved by the model
\begin{equation}
Y=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{2}+\beta_{1:2}x_{1}x_{2}+\epsilon,
\end{equation}
where the subscript \(1:2\) denotes that \(\beta_{1:2}\) is a coefficient
of an interaction term between \(x{}_{1}\) and \(x_{2}\). 
</p>


<p>
Consider the mean response \(\mu(x_{1},x_{2})\) as a function of \(x_{2}\):
\begin{equation}
\mu(x_{2})=(\beta_{0}+\beta_{1}x_{1})+\beta_{2}x_{2}.
\end{equation}
This is a linear function of \(x_{2}\) with slope \(\beta_{2}\). As \(x_{1}\) changes, the \(y\)-intercept of the mean response in \(x_{2}\) changes, but the slope remains the same. Therefore, the mean response in \(x_{2}\) is represented by a collection of parallel lines all with common slope \(\beta_{2}\).
</p>
<p>
Now think about what happens when the interaction term \(\beta_{1:2}x_{1}x_{2}\) is included. The mean response in \(x_{2}\) now looks like
\begin{equation}
\mu(x_{2})=(\beta_{0}+\beta_{1}x_{1})+(\beta_{2}+\beta_{1:2}x_{1})x_{2}.
\end{equation}
In this case we see that not only the \(y\)-intercept changes when \(x_{1}\) varies, but the slope also changes in \(x_{1}\). Thus, the interaction term allows the slope of the mean response in \(x_{2}\) to increase and decrease as \(x_{1}\) varies. 
</p>

<p>
There are several ways to introduce an interaction term into the model.
</p><ol>
<li>Make a new variable <code>prod &lt;- Girth * Height</code>, then include <code>prod</code> in the model formula <code>Volume ~ Girth + Height + prod</code>. This method is perhaps the most transparent, but it also reserves memory space unnecessarily.
</li>
<li>Construct an interaction term directly in \(\mathsf{R}\) with a colon <code>:</code>. For this example, the model formula would look like 
<pre class="example">
Volume ~ Girth + Height + Girth:Height 
</pre>

</li>
</ol>


<p>
For the <code>trees</code> data, we fit the model with the interaction using method two and see if it is significant:
</p>



<pre class="src src-R">treesint.lm <span style="color: #008b8b;">&lt;-</span> lm(Volume ~ Girth + Height + Girth:Height, data = trees)
summary(treesint.lm)
</pre>



<pre class="example">
Call:
lm(formula = Volume ~ Girth + Height + Girth:Height, data = trees)

Residuals:
    Min      1Q  Median      3Q     Max 
-6.5821 -1.0673  0.3026  1.5641  4.6649 

Coefficients:
             Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  69.39632   23.83575   2.911  0.00713 ** 
Girth        -5.85585    1.92134  -3.048  0.00511 ** 
Height       -1.29708    0.30984  -4.186  0.00027 ***
Girth:Height  0.13465    0.02438   5.524 7.48e-06 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 

Residual standard error: 2.709 on 27 degrees of freedom
Multiple R-squared: 0.9756,	Adjusted R-squared: 0.9728 
F-statistic: 359.3 on 3 and 27 DF,  p-value: &lt; 2.2e-16
</pre>


<p>
We can see from the output that the interaction term is highly significant. Further, the estimate \(b_{1:2}\) is positive. This means that the slope of \(\mu(x_{2})\) is steeper for bigger values of <code>Girth</code>. Keep in mind: the same interpretation holds for \(\mu(x_{1})\); that is, the slope of \(\mu(x_{1})\) is steeper for bigger values of <code>Height</code>.
</p>
<p>
For the sake of completeness we calculate confidence intervals for the parameters and do prediction as before.
</p>



<pre class="src src-R">confint(treesint.lm)
</pre>


<pre class="example">
                   2.5 %      97.5 %
(Intercept)  20.48938699 118.3032441
Girth        -9.79810354  -1.9135923
Height       -1.93282845  -0.6613383
Girth:Height  0.08463628   0.1846725
</pre>





<pre class="src src-R">new <span style="color: #008b8b;">&lt;-</span> data.frame(Girth = c(9.1, 11.6, 12.5), Height = c(69, 74, 87))
predict(treesint.lm, newdata = new, interval = <span style="color: #8b2252;">"prediction"</span>)
</pre>


<pre class="example">
       fit       lwr      upr
1 11.15884  5.236341 17.08134
2 21.07164 15.394628 26.74866
3 29.78862 23.721155 35.85608
</pre>


<p>
<div class="rem">
There are two other ways to include interaction terms in model formulas. For example, we could have written <code>Girth * Height</code> or even <code>(Girth + Height)^2</code> and both would be the same as <code>Girth + Height + Girth:Height</code>. 
</div>
</p>
<p>
These examples can be generalized to more than two independent variables, say three, four, or even more. We may be interested in seeing whether any pairwise interactions are significant. We do this with a model formula that looks something like <code>y ~ (x1 + x2 + x3 + x4)^2</code>.  
</p>
</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">Qualitative Explanatory Variables</h3>
<div class="outline-text-3" id="text-1-6">


<p>
We have so far been concerned with numerical independent variables taking values in a subset of real numbers. In this section, we extend our treatment to include the case in which one of the explanatory variables is qualitative, that is, a <i>factor</i>. Qualitative variables take values in a set of <i>levels</i>, which may or may not be ordered. See Section <a href="#sub-Qualitative-Data">Qualitative-Data</a>.
</p>
<p>
The <code>trees</code> data do not have any qualitative explanatory variables, so we will construct one for illustrative purposes
We will leave the <code>Girth</code> variable alone, but we will replace the variable <code>Height</code> by a new variable <code>Tall</code> which indicates whether or not the cherry tree is taller than a certain threshold (which for the sake of argument will be the sample median height of 76 ft). That is, <code>Tall</code> will be defined by
\begin{equation}
\mathtt{Tall}=
\begin{cases}
\mathtt{yes}, & \mbox{if }\mathtt{Height}>76,\\
\mathtt{no}, & \mbox{if }\mathtt{Height}\leq76.
\end{cases}
\end{equation}

We can construct <code>Tall</code> very quickly in \(\mathsf{R}\) with the <code>cut</code> function:
</p>



<pre class="src src-R">trees$Tall <span style="color: #008b8b;">&lt;-</span> cut(trees$Height, breaks = c(-<span style="color: #228b22;">Inf</span>, 76, <span style="color: #228b22;">Inf</span>), 
                  labels = c(<span style="color: #8b2252;">"no"</span>,<span style="color: #8b2252;">"yes"</span>))
trees$Tall[1:5]
</pre>


<pre class="example">
[1] no  no  no  no  yes
Levels: no yes
</pre>


<p>
Note that <code>Tall</code> is automatically generated to be a factor with the labels in the correct order. See <code>?cut</code> for more. 
</p>
<p>
Once we have <code>Tall</code>, we include it in the regression model just like we would any other variable. It is handled internally in a special way. Define a ``dummy variable'' <code>Tallyes</code> that takes values
\begin{equation}
\mathtt{Tallyes}=
\begin{cases}
1, & \mbox{if }\mathtt{Tall}=\mathtt{yes},\\
0, & \mbox{otherwise.}
\end{cases}
\end{equation}
That is, <code>Tallyes</code> is an <i>indicator variable</i> which indicates when a respective tree is tall. The model may now be written as 
\begin{equation}
\mathtt{Volume}=\beta_{0}+\beta_{1}\mathtt{Girth}+\beta_{2}\mathtt{Tallyes}+\epsilon.
\end{equation}
Let us take a look at what this definition does to the mean response. Trees with <code>Tall = yes</code> will have the mean response
\begin{equation}
\mu(\mathtt{Girth})=(\beta_{0}+\beta_{2})+\beta_{1}\mathtt{Girth},
\end{equation}
while trees with <code>Tall = no</code> will have the mean response
\begin{equation} 
\mu(\mathtt{Girth})=\beta_{0}+\beta_{1}\mathtt{Girth}.
\end{equation}
In essence, we are fitting two regression lines: one for tall trees, and one for short trees. The regression lines have the same slope but they have different \(y\) intercepts (which are exactly \(|\beta_{2}|\) far apart).
</p>

<p>
The important thing is to double check that the qualitative variable in question is stored as a factor. The way to check is with the <code>class</code> command. For example,
</p>



<pre class="src src-R">class(trees$Tall)
</pre>


<pre class="example">
[1] "factor"
</pre>


<p>
If the qualitative variable is not yet stored as a factor then we may convert it to one with the <code>factor</code> command. See Section <a href="#sub-Qualitative-Data">Qualitative-Data</a>. Other than this we perform MLR as we normally would.
</p>



<pre class="src src-R">treesdummy.lm <span style="color: #008b8b;">&lt;-</span> lm(Volume ~ Girth + Tall, data = trees)
summary(treesdummy.lm)
</pre>



<pre class="example">
Call:
lm(formula = Volume ~ Girth + Tall, data = trees)

Residuals:
    Min      1Q  Median      3Q     Max 
-5.7788 -3.1710  0.4888  2.6737 10.0619 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) -34.1652     3.2438  -10.53 3.02e-11 ***
Girth         4.6988     0.2652   17.72  &lt; 2e-16 ***
Tall[T.yes]   4.3072     1.6380    2.63   0.0137 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 

Residual standard error: 3.875 on 28 degrees of freedom
Multiple R-squared: 0.9481,	Adjusted R-squared: 0.9444 
F-statistic: 255.9 on 2 and 28 DF,  p-value: &lt; 2.2e-16
</pre>


<p>
From the output we see that all parameter estimates are statistically significant and we conclude that the mean response differs for trees with <code>Tall = yes</code> and trees with <code>Tall = no</code>.
</p>
<p>
<div class="rem">
We were somewhat disingenuous when we defined the dummy variable <code>Tallyes</code> because, in truth, \(\mathsf{R}\) defines <code>Tallyes</code> automatically without input from the user
Indeed, the author fit the model beforehand and wrote the discussion afterward with the knowledge of what \(\mathsf{R}\) would do so that the output the reader saw would match what (s)he had previously read. The way that \(\mathsf{R}\) handles factors internally is part of a much larger topic concerning <i>contrasts</i>, which falls outside the scope of this book. The interested reader should see Neter et al \cite{Neter1996} or Fox \cite{Fox1997} for more. 
</div>
</p>
<p>
<div class="rem">
In general, if an explanatory variable <code>foo</code> is qualitative with \(n\) levels <code>bar1</code>, <code>bar2</code>, &hellip;, <code>barn</code> then \(\mathsf{R}\) will by default automatically define \(n-1\) indicator variables in the following way:
\begin{eqnarray*}
\mathtt{foobar2} & = & \begin{cases}
1, & \mbox{if }\mathtt{foo}=\mathtt{"bar2"},\\
0, & \mbox{otherwise.}\end{cases},\,\ldots,\,\mathtt{foobarn}=\begin{cases}
1, & \mbox{if }\mathtt{foo}=\mathtt{"barn"},\\
0, & \mbox{otherwise.}\end{cases}
\end{eqnarray*}
The level <code>bar1</code> is represented by \(\mathtt{foobar2}=\cdots=\mathtt{foobarn}=0\). We just need to make sure that <code>foo</code> is stored as a factor and \(\mathsf{R}\) will take care of the rest. 
</div>
</p>

</div>

<div id="outline-container-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">Graphing the Regression Lines</h4>
<div class="outline-text-4" id="text-1-6-1">


<p>
We can see a plot of the two regression lines with the following mouthful of code.
</p>









<div id="fig-dummy-variable-trees" class="figure">
  <p><img src="svg/dummy-variable-trees.svg" width=500 alt="svg/dummy-variable-trees.svg" /></p>
  <p>A dummy variable model for the <code>trees</code> data.</p>
</div>

<p>
It may look intimidating but there is reason to the madness. First we <code>split</code> the <code>trees</code> data into two pieces, with groups determined by the <code>Tall</code> variable. Next we add the \texttt{Fit}ted values to each piece via <code>predict</code>. Then we set up a <code>plot</code> for the variables <code>Volume</code> versus <code>Girth</code>, but we do not plot anything yet (<code>type = n</code>) because we want to use different symbols for the two groups. Next we add <code>points</code> to the plot for the <code>Tall = yes</code> trees and use an open circle for a plot character (<code>pch = 1</code>), followed by <code>points</code> for the <code>Tall = no</code> trees with a triangle character (<code>pch = 2</code>). Finally, we add regression <code>lines</code> to the plot, one for each group.
</p>
<p>
There are other &ndash; shorter &ndash; ways to plot regression lines by groups, namely the <code>scatterplot</code> function in the <code>car</code> \cite{car} package and the <code>xyplot</code> function in the <code>lattice</code> package. We elected to introduce the reader to the above approach since many advanced plots in \(\mathsf{R}\) are done in a similar, consecutive fashion.
</p>
</div>
</div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">Partial <i>F</i> Statistic</h3>
<div class="outline-text-3" id="text-1-7">


<p>
We saw in Section <a href="#sub-mlr-Overall-F-Test">mlr-Overall-F-Test</a> how to test \(H_{0}:\beta_{0}=\beta_{1}=\cdots=\beta_{p}=0\) with the overall \(F\) statistic and we saw in Section <a href="#sub-mlr-Student-s-t-Tests">mlr-Student's-t-Tests</a> how to test \(H_{0}:\beta_{i}=0\) that a particular coefficient \(\beta_{i}\) is zero. Sometimes, however, we would like to test whether a certain part of the model is significant. Consider the regression model
\begin{equation}
Y=\beta_{0}+\beta_{1}x_{1}+\cdots+\beta_{j}x_{j}+\beta_{j+1}x_{j+1}+\cdots+\beta_{p}x_{p}+\epsilon,
\end{equation}
where \(j\geq1\) and \(p\geq2\). Now we wish to test the hypothesis
\begin{equation}
H_{0}:\beta_{j+1}=\beta_{j+2}=\cdots=\beta_{p}=0
\end{equation}
versus the alternative 
\begin{equation}
H_{1}:\mbox{at least one of $\beta_{j+1},\ \beta_{j+2},\ ,\ldots,\beta_{p}\neq0$}.
\end{equation}

The interpretation of \(H_{0}\) is that none of the variables \(x_{j+1}\), &hellip;,\(x_{p}\) is significantly related to \(Y\) and the interpretation of \(H_{1}\) is that at least one of \(x_{j+1}\), &hellip;,\(x_{p}\) is significantly related to \(Y\). In essence, for this hypothesis test there are two competing models under consideration:
\begin{align}
\mbox{the full model:} & \quad y=\beta_{0}+\beta_{1}x_{1}+\cdots+\beta_{p}x_{p}+\epsilon,\\
\mbox{the reduced model:} & \quad y=\beta_{0}+\beta_{1}x_{1}+\cdots+\beta_{j}x_{j}+\epsilon,
\end{align}

Of course, the full model will always explain the data <i>better</i> than the reduced model, but does the full model explain the data <i>significantly better</i> than the reduced model? This question is exactly what the partial \(F\) statistic is designed to answer.
</p>
<p>
We first calculate \(SSE_{f}\), the unexplained variation in the full model, and \(SSE_{r}\), the unexplained variation in the reduced model. We base our test on the difference \(SSE_{r}-SSE_{f}\) which measures the reduction in unexplained variation attributable to the variables \(x_{j+1}\), &hellip;, \(x_{p}\). In the full model there are \(p+1\) parameters and in the reduced model there are \(j+1\) parameters, which gives a difference of \(p-j\) parameters (hence degrees of freedom). The partial <i>F</i> statistic is 
\begin{equation}
F=\frac{(SSE_{r}-SSE_{f})/(p-j)}{SSE_{f}/(n-p-1)}.
\end{equation}
It can be shown when the regression assumptions hold under \(H_{0}\) that the partial \(F\) statistic has an \(\mathsf{f}(\mathtt{df1}=p-j,\,\mathtt{df2}=n-p-1)\) distribution. We calculate the \(p\)-value of the observed partial \(F\) statistic and reject \(H_{0}\) if the \(p\)-value is small. 
</p>


<p>
The key ingredient above is that the two competing models are <i>nested</i> in the sense that the reduced model is entirely contained within the complete model. The way to test whether the improvement is significant is to compute <code>lm</code> objects both for the complete model and the reduced model then compare the answers with the <code>anova</code> function.
</p>

<p>
For the <code>trees</code> data, let us fit a polynomial regression model and for the sake of argument we will ignore our own good advice and fail to rescale the explanatory variables. 
</p>



<pre class="src src-R">treesfull.lm <span style="color: #008b8b;">&lt;-</span> lm(Volume ~ Girth + I(Girth^2) + Height + 
                   I(Height^2), data = trees)
summary(treesfull.lm)
</pre>



<pre class="example">X11cairo 
       2
 
Call:
lm(formula = Volume ~ Girth + I(Girth^2) + Height + I(Height^2), 
    data = trees)

Residuals:
   Min     1Q Median     3Q    Max 
-4.368 -1.670 -0.158  1.792  4.358 

Coefficients:
             Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) -0.955101  63.013630  -0.015    0.988    
Girth       -2.796569   1.468677  -1.904    0.068 .  
I(Girth^2)   0.265446   0.051689   5.135 2.35e-05 ***
Height       0.119372   1.784588   0.067    0.947    
I(Height^2)  0.001717   0.011905   0.144    0.886    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 

Residual standard error: 2.674 on 26 degrees of freedom
Multiple R-squared: 0.9771,	Adjusted R-squared: 0.9735 
F-statistic:   277 on 4 and 26 DF,  p-value: &lt; 2.2e-16
</pre>


<p>
In this ill-formed model nothing is significant except <code>Girth</code> and <code>Girth^2</code>. Let us continue down this path and suppose that we would like to try a reduced model which contains nothing but <code>Girth</code> and <code>Girth^2</code> (not even an <code>Intercept</code>). Our two models are now
\begin{align*} 
\mbox{the full model:} & \quad Y=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{1}^{2}+\beta_{3}x_{2}+\beta_{4}x_{2}^{2}+\epsilon,\\
\mbox{the reduced model:} & \quad Y=\beta_{1}x_{1}+\beta_{2}x_{1}^{2}+\epsilon,
\end{align*}
We fit the reduced model with <code>lm</code> and store the results:
</p>



<pre class="src src-R">treesreduced.lm <span style="color: #008b8b;">&lt;-</span> lm(Volume ~ -1 + Girth + I(Girth^2), data = trees)
</pre>


<p>
To delete the intercept from the model we used <code>-1</code> in the model formula. Next we compare the two models with the <code>anova</code> function. The convention is to list the models from smallest to largest.
</p>



<pre class="src src-R">anova(treesreduced.lm, treesfull.lm)
</pre>


<pre class="example">
 Analysis of Variance Table

Model 1: Volume ~ -1 + Girth + I(Girth^2)
Model 2: Volume ~ Girth + I(Girth^2) + Height + I(Height^2)
  Res.Df    RSS Df Sum of Sq      F   Pr(&gt;F)   
1     29 321.65                                
2     26 185.86  3    135.79 6.3319 0.002279 **
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
</pre>


<p>
We see from the output that the complete model is highly significant compared to the model that does not incorporate <code>Height</code> or the <code>Intercept</code>. We wonder (with our tongue in our cheek) if the <code>Height^2</code> term in the full model is causing all of the trouble. We will fit an alternative reduced model that only deletes <code>Height^2</code>. 
</p>



<pre class="src src-R">treesreduced2.lm <span style="color: #008b8b;">&lt;-</span> lm(Volume ~ Girth + I(Girth^2) + Height, 
                       data = trees)
anova(treesreduced2.lm, treesfull.lm)
</pre>


<pre class="example">
 Analysis of Variance Table

Model 1: Volume ~ Girth + I(Girth^2) + Height
Model 2: Volume ~ Girth + I(Girth^2) + Height + I(Height^2)
  Res.Df    RSS Df Sum of Sq      F Pr(&gt;F)
1     27 186.01                           
2     26 185.86  1   0.14865 0.0208 0.8865
</pre>


<p>
In this case, the improvement to the reduced model that is attributable to <code>Height^2</code> is not significant, so we can delete <code>Height^2</code> from the model with a clear conscience. We notice that the <i>p-value</i> for this latest partial \(F\) test is 0.8865, which seems to be remarkably close to the <i>p-value</i> we saw for the univariate <i>t</i> test of <code>Height^2</code> at the beginning of this example. In fact, the <i>p-values</i> are <i>exactly</i> the same. Perhaps now we gain some insight into the true meaning of the univariate tests.
</p>

</div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">Residual Analysis and Diagnostic Tools</h3>
<div class="outline-text-3" id="text-1-8">


<p>
We encountered many, many diagnostic measures for simple linear regression in Sections <a href="#sec-Residual-Analysis-SLR">Residual-Analysis-SLR</a> and <a href="#sec-Other-Diagnostic-Tools-SLR">Other-Diagnostic-Tools-SLR</a>. All of these are valid in multiple linear regression, too, but there are some slight changes that we need to make for the multivariate case. We list these below, and apply them to the trees example.  
</p>
<dl>
<dt>Shapiro-Wilk, Breusch-Pagan, Durbin-Watson:</dt><dd>unchanged from SLR, but we are now equipped to talk about the Shapiro-Wilk test statistic for the residuals. It is defined by the formula 
   \begin{equation}
   W=\frac{\mathbf{a}^{\mathrm{T}}\mathbf{E}^{\ast}}{\mathbf{E}^{\mathrm{T}}\mathbf{E}},
   \end{equation}
   where \(\mathbf{E}^{\ast}\) is the sorted residuals and \(\mathbf{a}_{1\times\mathrm{n}}\) is defined by 
   \begin{equation}
   \mathbf{a}=\frac{\mathbf{m}^{\mathrm{T}}\mathbf{V}^{-1}}{\sqrt{\mathbf{m}^{\mathrm{T}}\mathbf{V}^{-1}\mathbf{V}^{-1}\mathbf{m}}},
   \end{equation}
   where \(\mathbf{m}_{\mathrm{n}\times1}\) and \(\mathbf{V}_{\mathrm{n}\times\mathrm{n}}\) are the mean and covariance matrix, respectively, of the order statistics from an \(\mathsf{mvnorm}\left(\mathtt{mean}=\mathbf{0},\,\mathtt{sigma}=\mathbf{I}\right)\) distribution. 
</dd>
<dt>Leverages:</dt><dd>are defined to be the diagonal entries of the hat matrix \(\mathbf{H}\) (which is why we called them \(h_{ii}\) in Section <a href="#sub-mlr-point-est-regsurface">mlr-point-est-regsurface</a>). The sum of the leverages is \(\mbox{tr}(\mathbf{H})=p+1\). One rule of thumb considers a leverage extreme if it is larger than double the mean leverage value, which is \(2(p+1)/n\), and another rule of thumb considers leverages bigger than 0.5 to indicate high leverage, while values between 0.3 and 0.5 indicate moderate leverage.
</dd>
<dt>Standardized residuals:</dt><dd>unchanged. Considered extreme if \(|R_{i}|&gt;2\). 
</dd>
<dt>Studentized residuals:</dt><dd>compared to a \(\mathsf{t}(\mathtt{df}=n-p-2)\) distribution.  
</dd>
<dt>DFBETAS:</dt><dd>The formula is generalized to
   \begin{equation}
   (DFBETAS)_{j(i)}=\frac{b_{j}-b_{j(i)}}{S_{(i)}\sqrt{c_{jj}}},\quad j=0,\ldots p,\ i=1,\ldots,n,
   \end{equation}
   where \(c_{jj}\) is the \(j^{\mathrm{th}}\) diagonal entry of \((\mathbf{X}^{\mathrm{T}}\mathbf{X})^{-1}\). Values larger than one for small data sets or \(2/\sqrt{n}\) for large data sets should be investigated.
</dd>
<dt>DFFITS:</dt><dd>unchanged. Larger than one in absolute value is considered extreme.
</dd>
<dt>Cook's D:</dt><dd>compared to an \(\mathsf{f}(\mathtt{df1}=p+1,\,\mathtt{df2}=n-p-1)\) distribution. Observations falling higher than the 50\(^{\textrm{th}}\) percentile are extreme. 
</dd>
</dl>

<p>Note that plugging the value \(p=1\) into the formulas will recover all of the ones we saw in Chapter <a href="#cha-simple-linear-regression">simple-linear-regression</a>.
</p>
</div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">Additional Topics</h3>
<div class="outline-text-3" id="text-1-9">



</div>

<div id="outline-container-1-9-1" class="outline-4">
<h4 id="sec-1-9-1">Nonlinear Regression</h4>
<div class="outline-text-4" id="text-1-9-1">


<p>
We spent the entire chapter talking about the <code>trees</code> data, and all of our models looked like <code>Volume ~ Girth + Height</code> or a variant of this model. But let us think again: we know from elementary school that the volume of a rectangle is \(V=lwh\) and the volume of a cylinder (which is closer to what a black cherry tree looks like) is
\begin{equation}
V=\pi r^{2}h\quad\mbox{or}\quad V=4\pi dh,
\end{equation}
where \(r\) and \(d\) represent the radius and diameter of the tree, respectively. With this in mind, it would seem that a more appropriate model for \(\mu\) might be
\begin{equation}
\mu(x_{1},x_{2})=\beta_{0}x_{1}^{\beta_{1}}x_{2}^{\beta_{2}},\label{eq:trees-nonlin-reg}
\end{equation}
where \(\beta_{1}\) and \(\beta_{2}\) are parameters to adjust for the fact that a black cherry tree is not a perfect cylinder.
</p>
<p>
How can we fit this model? The model is not linear in the parameters any more, so our linear regression methods will not work&hellip; or will they? In the <code>trees</code> example we may take the logarithm of both sides of Equation <a href="#eq-trees-nonlin-reg">trees-nonlin-reg</a> to get
\begin{equation}
\mu^{\ast}(x_{1},x_{2})=\ln\left[\mu(x_{1},x_{2})\right]=\ln\beta_{0}+\beta_{1}\ln x_{1}+\beta_{2}\ln x_{2},
\end{equation}
and this new model \(\mu^{\ast}\) is linear in the parameters \(\beta_{0}^{\ast}=\ln\beta_{0}\), \(\beta_{1}^{\ast}=\beta_{1}\) and \(\beta_{2}^{\ast}=\beta_{2}\). We can use what we have learned to fit a linear model <code>log(Volume) ~ log(Girth) + log(Height)</code>, and everything will proceed as before, with one exception: we will need to be mindful when it comes time to make predictions because the model will have been fit on the log scale, and we will need to transform our predictions back to the original scale (by exponentiating with <code>exp</code>) to make sense.
</p>



<pre class="src src-R">treesNonlin.lm <span style="color: #008b8b;">&lt;-</span> lm(log(Volume) ~ log(Girth) + log(Height), 
                     data = trees)
summary(treesNonlin.lm)
</pre>



<pre class="example"> 
Call:
lm(formula = log(Volume) ~ log(Girth) + log(Height), data = trees)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.168561 -0.048488  0.002431  0.063637  0.129223 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) -6.63162    0.79979  -8.292 5.06e-09 ***
log(Girth)   1.98265    0.07501  26.432  &lt; 2e-16 ***
log(Height)  1.11712    0.20444   5.464 7.81e-06 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 

Residual standard error: 0.08139 on 28 degrees of freedom
Multiple R-squared: 0.9777,	Adjusted R-squared: 0.9761 
F-statistic: 613.2 on 2 and 28 DF,  p-value: &lt; 2.2e-16
</pre>


<p>
This is our best model yet (judging by \(R^{2}\) and \(\overline{R}^{2}\)), all of the parameters are significant, it is simpler than the quadratic or interaction models, and it even makes theoretical sense. It rarely gets any better than that.
</p>
<p>
We may get confidence intervals for the parameters, but remember that it is usually better to transform back to the original scale for interpretation purposes :
</p>



<pre class="src src-R">exp(confint(treesNonlin.lm))
</pre>


<pre class="example">
                   2.5 %      97.5 %
(Intercept) 0.0002561078 0.006783093
log(Girth)  6.2276411645 8.468066317
log(Height) 2.0104387829 4.645475188
</pre>


<p>
(Note that we did not update the row labels of the matrix to show that we exponentiated and so they are misleading as written.) We do predictions just as before. Remember to transform the response variable back to the original scale after prediction. 
</p>



<pre class="src src-R">new <span style="color: #008b8b;">&lt;-</span> data.frame(Girth = c(9.1, 11.6, 12.5), Height = c(69, 74, 87))
exp(predict(treesNonlin.lm, newdata = new, interval = <span style="color: #8b2252;">"confidence"</span>))
</pre>


<pre class="example">
       fit      lwr      upr
1 11.90117 11.25908 12.57989
2 20.82261 20.14652 21.52139
3 28.93317 27.03755 30.96169
</pre>


<p>
The predictions and intervals are slightly different from those calculated earlier, but they are close. Note that we did not need to transform the <code>Girth</code> and <code>Height</code> arguments in the dataframe <code>new</code>. All transformations are done for us automatically.
</p>
</div>

</div>

<div id="outline-container-1-9-2" class="outline-4">
<h4 id="sec-1-9-2">Real Nonlinear Regression</h4>
<div class="outline-text-4" id="text-1-9-2">


<p>
We saw with the <code>trees</code> data that a nonlinear model might be more appropriate for the data based on theoretical considerations, and we were lucky because the functional form of \(\mu\) allowed us to take logarithms to transform the nonlinear model to a linear one. The same trick will not work in other circumstances, however. We need techniques to fit general models of the form
\begin{equation}
\mathbf{Y}=\mu(\mathbf{X})+\epsilon,
\end{equation}
where \(\mu\) is some crazy function that does not lend itself to linear transformations.
</p>
<p>
There are a host of methods to address problems like these which are studied in advanced regression classes. The interested reader should see Neter <i>et al</i> \cite{Neter1996} or Tabachnick and Fidell \cite{Tabachnick2006}. 
</p>
<p>
It turns out that John Fox has posted an Appendix to his book \cite{Fox2002} which discusses some of the methods and issues associated with nonlinear regression; see <a href="http://cran.r-project.org/doc/contrib/Fox-Companion/appendix.html">here</a> for more.  Here is an example of how it works, based on a question from R-help.
</p>



<pre class="src src-R"><span style="color: #b22222;"># </span><span style="color: #b22222;">fake data </span>
set.seed(1) 
x <span style="color: #008b8b;">&lt;-</span> seq(from = 0, to = 1000, length.out = 200) 
y <span style="color: #008b8b;">&lt;-</span> 1 + 2*(sin((2*pi*x/360) - 3))^2 + rnorm(200, sd = 2)
<span style="color: #b22222;"># </span><span style="color: #b22222;">plot(x, y)</span>
acc.nls <span style="color: #008b8b;">&lt;-</span> nls(y ~ a + b*(sin((2*pi*x/360) - c))^2, 
               start = list(a = 0.9, b = 2.3, c = 2.9))
summary(acc.nls)
<span style="color: #b22222;">#</span><span style="color: #b22222;">plot(x, fitted(acc.nls))</span>
</pre>



<pre class="example"> 
Formula: y ~ a + b * (sin((2 * pi * x/360) - c))^2

Parameters:
  Estimate Std. Error t value Pr(&gt;|t|)    
a  0.95884    0.23097   4.151 4.92e-05 ***
b  2.22868    0.37114   6.005 9.07e-09 ***
c  3.04343    0.08434  36.084  &lt; 2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 

Residual standard error: 1.865 on 197 degrees of freedom

Number of iterations to convergence: 3 
Achieved convergence tolerance: 6.546e-08
</pre>


</div>

</div>

<div id="outline-container-1-9-3" class="outline-4">
<h4 id="sec-1-9-3">Multicollinearity</h4>
<div class="outline-text-4" id="text-1-9-3">


<p>
A multiple regression model exhibits <i>multicollinearity</i> when two or more of the explanatory variables are substantially correlated with each other. We can measure multicollinearity by having one of the explanatory play the role of ``dependent variable'' and regress it on the remaining explanatory variables. The the \(R^{2}\) of the resulting model is near one, then we say that the model is multicollinear or shows multicollinearity.
</p>
<p>
Multicollinearity is a problem because it causes instability in the regression model. The instability is a consequence of redundancy in the explanatory variables: a high \(R^{2}\) indicates a strong dependence between the selected independent variable and the others. The redundant information inflates the variance of the parameter estimates which can cause them to be statistically insignificant when they would have been significant otherwise. To wit, multicollinearity is usually measured by what are called <i>variance inflation factors</i>.
</p>
<p>
Once multicollinearity has been diagnosed there are several approaches to remediate it. Here are a couple of important ones. 
</p><dl>
<dt>Principal Components Analysis.</dt><dd>This approach casts out two or more of the original explanatory variables and replaces them with new variables, derived from the original ones, that are by design uncorrelated with one another. The redundancy is thus eliminated and we may proceed as usual with the new variables in hand. Principal Components Analysis is important for other reasons, too, not just for fixing multicollinearity problems.
</dd>
<dt>Ridge Regression.</dt><dd>The idea of this approach is to replace the original parameter estimates with a different type of parameter estimate which is more stable under multicollinearity. The estimators are not found by ordinary least squares but rather a different optimization procedure which incorporates the variance inflation factor information. 
</dd>
</dl>


<p>
We decided to omit a thorough discussion of multicollinearity because we are not equipped to handle the mathematical details. Perhaps the topic will receive more attention in a later edition.
</p>
<ul>
<li>What to do when data are not normal
<ul>
<li>Bootstrap (see Chapter <a href="#cha-resampling-methods">resampling-methods</a>).
</li>
</ul>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-9-4" class="outline-4">
<h4 id="sec-1-9-4">Akaike's Information Criterion</h4>
<div class="outline-text-4" id="text-1-9-4">




\[
AIC=-2\ln L+2(p+1)
\]



</div>
</div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10">Chapter Exercises</h3>
<div class="outline-text-3" id="text-1-10">



<p>
<div class="xca">
Use Equations <a href="#eq-mlr-sse-matrix">mlr-sse-matrix</a>, <a href="#eq-mlr-ssto-matrix">mlr-ssto-matrix</a>, and <a href="#eq-mlr-ssr-matrix">mlr-ssr-matrix</a> to prove the Anova Equality:
\[
SSTO=SSE+SSR.
\]
</div>
</p></div>
</div>
</div>
